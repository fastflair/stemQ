{
       "Course": "Unified Engineering 3 and 4",
       "Topic": "Unified Computers and programming",
       "Original question": "What is the Big-O complexity of:\na. Heapify function\nb. Build_Heap function\nc. Heap_Sort.   Show all the steps in the computation of the Big-O complexity.",
       "Solution": "a. Heapify function\nA heap is an array that satisfies the heap properties i.e., A(i) \u2264 A(2i) and A(i) \u2264 A(2i+1).\nThe heapify function at \u201di\u2018 makes A(i .. n) satisfy the heap property, under the assumption that the subtrees at A(2i) and A(2i+1) already satisfy the heap property.\nHeapify function Cost\nLchild := Left(I); c1 Rchild := Right(I); c2 if (Lchild <= Heap_Size and Heap_Array(Lchild) > Heap_Array(I)) c3\nLargest:= Lchild; c4 else c5 Largest := I; c6\nif (Rchild <= Heap_Size) c7 if Heap_Array(Rchild) > Heap_Array(Largest) c8 Largest := Rchild; c9\nif (Largest /= I) then c10 Swap(Heap_Array, I, Largest); c11 Heapify(Heap_Array, Largest); T(2n/3)\nT(n) = T(2n/3) + C\u2018\n= T(2n/3) + O(1)\na = 1, b = 3/2, f(n) = 1, therefore by master theorem,\nT(n) =O(nlogbalogn) = O (nlog3/2 1 logn)\n= O(1 * log n) = O(log n)\nThe important point to note here is the T(2n/3) term, which arises in the worst case, when the heap is asymmetric, i.e., the right subtree has one level less than the left subtree (or vice-versa).\nb.\nBuild_Heap function\nCode\nHeap_Size := Size;\nfor I in reverse 1 .. (Size/2) loop\nHeapify(Heap_Array, I); end loop;\nTherefore T(n) = c1+ n/2+1 + (n/2)log n + n/2 = (nlog(n))/2 + n + (c1+1)\nCost t(n)\nc1\nn/2+1 (n/2) log n n/2\n\nSimplifying\n=> T(n) = O(n log(n) )\nc. Heap_Sort\nHeap Sort\nBuild_Heap(Heap_Array, Size); for I in reverse 2.. size loop Swap(Heap_Array, 1, I);\nHeap_Size:= Heap_Size -1; Heapify(Heap_Array, 1);\nT(n) = 2 O(nlogn) + (c1+c2+1)n - O(log n) + = 2 O(nlog n) - O(log n) + c\u2018n\nSimplifying,\n=> T(n) = O(nlogn)\nCost t(n)\nO(nlogn))\nn\nc1(n-1) c2(n-1) O(log n)(n-1)"
}